# ZooKeeper相关概念总结(进阶)

# ZooKeeper相关概念总结(进阶)
## 什么是 ZooKeeper
ZooKeeper由Yahoo开发，后来捐赠给了Apache，现已成为Apache顶级项目。ZooKeeper是一个开源的分布式应用程序协调服务器，其为分布式系统提供一致性服务。其一致性是通过基于Paxos算法的ZAB协议完成的。其主要功能包括：配置维护、分布式同步、集群管理、分布式事务等。

简单来说，ZooKeeper是一个**分布式协调服务框架**。分布式？协调服务？这啥玩意？🤔🤔

其实解释到分布式这个概念的时候，我发现有些同学并不是能把**分布式和集群**这两个概念很好的理解透。前段时间有同学和我探讨起分布式的东西，他说分布式不就是加机器吗？一台机器不够用再加一台抗压呗。当然加机器这种说法也无可厚非，你一个分布式系统必定涉及到多个机器，但是你别忘了，计算机学科中还有一个相似的概念——Cluster，集群不也是加机器吗？但是 集群 和 分布式 其实就是两个完全不同的概念。

比如，我现在有一个秒杀服务，并发量太大单机系统承受不住，那我加几台服务器也**一样**提供秒杀服务，这个时候就是**Cluster****集群**。

![1732497841260-8da8c7f1-e51f-4a90-bd98-c39110ef3ebd.jpeg](./img/xOpCaObUO6drnWGP/1732497841260-8da8c7f1-e51f-4a90-bd98-c39110ef3ebd-585135.jpeg)

cluster

但是，我现在换一种方式，我将一个秒杀服务**拆分成多个子服务**，比如创建订单服务，增加积分服务，扣优惠券服务等等，**然后我将这些子服务都部署在不同的服务器上**，这个时候就是**Distributed****分布式**。

![1732497841345-5c91edac-636e-4ee4-8829-4460a89f5b9e.jpeg](./img/xOpCaObUO6drnWGP/1732497841345-5c91edac-636e-4ee4-8829-4460a89f5b9e-951963.jpeg)

distributed

而我为什么反驳同学所说的分布式就是加机器呢？因为我认为加机器更加适用于构建集群，因为它真是只有加机器。而对于分布式来说，你首先需要将业务进行拆分，然后再加机器（不仅仅是加机器那么简单），同时你还要去解决分布式带来的一系列问题。

![1732497841478-0c744354-dd35-4c61-9581-e5fc081623e0.jpeg](./img/xOpCaObUO6drnWGP/1732497841478-0c744354-dd35-4c61-9581-e5fc081623e0-290497.jpeg)

比如各个分布式组件如何协调起来，如何减少各个系统之间的耦合度，分布式事务的处理，如何去配置整个分布式系统等等。ZooKeeper主要就是解决这些问题的。

## 一致性问题
设计一个分布式系统必定会遇到一个问题——**因为分区容忍性（partition tolerance）的存在，就必定要求我们需要在系统可用性（availability）和数据一致性（consistency）中做出权衡**。这就是著名的CAP定理。

理解起来其实很简单，比如说把一个班级作为整个系统，而学生是系统中的一个个独立的子系统。这个时候班里的小红小明偷偷谈恋爱被班里的大嘴巴小花发现了，小花欣喜若狂告诉了周围的人，然后小红小明谈恋爱的消息在班级里传播起来了。当在消息的传播（散布）过程中，你抓到一个同学问他们的情况，如果回答你不知道，那么说明整个班级系统出现了数据不一致的问题（因为小花已经知道这个消息了）。而如果他直接不回答你，因为整个班级有消息在进行传播（为了保证一致性，需要所有人都知道才可提供服务），这个时候就出现了系统的可用性问题。

![1732497841966-44584867-7b08-4fe0-a48f-9b3bed0efbd5.jpeg](./img/xOpCaObUO6drnWGP/1732497841966-44584867-7b08-4fe0-a48f-9b3bed0efbd5-800316.jpeg)

而上述前者就是Eureka的处理方式，它保证了 AP（可用性），后者就是我们今天所要讲的ZooKeeper的处理方式，它保证了 CP（数据一致性）。

## 一致性协议和算法
而为了解决数据一致性问题，在科学家和程序员的不断探索中，就出现了很多的一致性协议和算法。比如 2PC（两阶段提交），3PC（三阶段提交），Paxos 算法等等。

这时候请你思考一个问题，同学之间如果采用传纸条的方式去传播消息，那么就会出现一个问题——我咋知道我的小纸条有没有传到我想要传递的那个人手中呢？万一被哪个小家伙给劫持篡改了呢，对吧？

![1732497842146-0850ee29-2cd5-448d-af25-60de185264b4.jpeg](./img/xOpCaObUO6drnWGP/1732497842146-0850ee29-2cd5-448d-af25-60de185264b4-295687.jpeg)

这个时候就引申出一个概念——**拜占庭将军问题**。它意指**在不可靠信道上试图通过消息传递的方式达到一致性是不可能的**， 所以所有的一致性算法的**必要前提**就是安全可靠的消息通道。

而为什么要去解决数据一致性的问题？你想想，如果一个秒杀系统将服务拆分成了下订单和加积分服务，这两个服务部署在不同的机器上了，万一在消息的传播过程中积分系统宕机了，总不能你这边下了订单却没加积分吧？你总得保证两边的数据需要一致吧？

### 2PC（两阶段提交）
两阶段提交是一种保证分布式系统数据一致性的协议，现在很多数据库都是采用的两阶段提交协议来完成**分布式事务**的处理。

在介绍 2PC 之前，我们先来想想分布式事务到底有什么问题呢？

还拿秒杀系统的下订单和加积分两个系统来举例吧（我想你们可能都吐了 🤮🤮🤮），我们此时下完订单会发个消息给积分系统告诉它下面该增加积分了。如果我们仅仅是发送一个消息也不收回复，那么我们的订单系统怎么能知道积分系统的收到消息的情况呢？如果我们增加一个收回复的过程，那么当积分系统收到消息后返回给订单系统一个Response，但在中间出现了网络波动，那个回复消息没有发送成功，订单系统是不是以为积分系统消息接收失败了？它是不是会回滚事务？但此时积分系统是成功收到消息的，它就会去处理消息然后给用户增加积分，这个时候就会出现积分加了但是订单没下成功。

所以我们所需要解决的是在分布式系统中，整个调用链中，我们所有服务的数据处理要么都成功要么都失败，即所有服务的**原子性问题**。

在两阶段提交中，主要涉及到两个角色，分别是协调者和参与者。

第一阶段：当要执行一个分布式事务的时候，事务发起者首先向协调者发起事务请求，然后协调者会给所有参与者发送prepare请求（其中包括事务内容）告诉参与者你们需要执行事务了，如果能执行我发的事务内容那么就先执行但不提交，执行后请给我回复。然后参与者收到prepare消息后，他们会开始执行事务（但不提交），并将Undo和Redo信息记入事务日志中，之后参与者就向协调者反馈是否准备好了。

第二阶段：第二阶段主要是协调者根据参与者反馈的情况来决定接下来是否可以进行事务的提交操作，即提交事务或者回滚事务。

比如这个时候**所有的参与者**都返回了准备好了的消息，这个时候就进行事务的提交，协调者此时会给所有的参与者发送**Commit****请求**，当参与者收到Commit请求的时候会执行前面执行的事务的**提交操作**，提交完毕之后将给协调者发送提交成功的响应。

而如果在第一阶段并不是所有参与者都返回了准备好了的消息，那么此时协调者将会给所有参与者发送**回滚事务的****rollback****请求**，参与者收到之后将会**回滚它在第一阶段所做的事务处理**，然后再将处理情况返回给协调者，最终协调者收到响应后便给事务发起者返回处理失败的结果。

![1732497842262-7c27e0e7-932e-4261-82e9-fa62721b9d48.jpeg](./img/xOpCaObUO6drnWGP/1732497842262-7c27e0e7-932e-4261-82e9-fa62721b9d48-184603.jpeg)

2PC流程

个人觉得 2PC 实现得还是比较鸡肋的，因为事实上它只解决了各个事务的原子性问题，随之也带来了很多的问题。

![1732497842406-ee862489-3de8-41fa-b76b-411f34f2c772.jpeg](./img/xOpCaObUO6drnWGP/1732497842406-ee862489-3de8-41fa-b76b-411f34f2c772-546562.jpeg)

+ **单点故障问题**，如果协调者挂了那么整个系统都处于不可用的状态了。
+ **阻塞问题**，即当协调者发送prepare请求，参与者收到之后如果能处理那么它将会进行事务的处理但并不提交，这个时候会一直占用着资源不释放，如果此时协调者挂了，那么这些资源都不会再释放了，这会极大影响性能。
+ **数据不一致问题**，比如当第二阶段，协调者只发送了一部分的commit请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题。

### 3PC（三阶段提交）
因为 2PC 存在的一系列问题，比如单点，容错机制缺陷等等，从而产生了**3PC（三阶段提交）**。那么这三阶段又分别是什么呢？

千万不要吧 PC 理解成个人电脑了，其实他们是 phase-commit 的缩写，即阶段提交。

1. **CanCommit 阶段**：协调者向所有参与者发送CanCommit请求，参与者收到请求后会根据自身情况查看是否能执行事务，如果可以则返回 YES 响应并进入预备状态，否则返回 NO 。
2. **PreCommit 阶段**：协调者根据参与者返回的响应来决定是否可以进行下面的PreCommit操作。如果上面参与者返回的都是 YES，那么协调者将向所有参与者发送PreCommit预提交请求，**参与者收到预提交请求后，会进行事务的执行操作，并将****Undo****和****Redo****信息写入事务日志中**，最后如果参与者顺利执行了事务则给协调者返回成功的响应。如果在第一阶段协调者收到了**任何一个 NO**的信息，或者**在一定时间内**并没有收到全部的参与者的响应，那么就会中断事务，它会向所有参与者发送中断请求（abort），参与者收到中断请求之后会立即中断事务，或者在一定时间内没有收到协调者的请求，它也会中断事务。
3. **DoCommit 阶段**：这个阶段其实和2PC的第二阶段差不多，如果协调者收到了所有参与者在PreCommit阶段的 YES 响应，那么协调者将会给所有参与者发送DoCommit请求，**参与者收到****DoCommit****请求后则会进行事务的提交工作**，完成后则会给协调者返回响应，协调者收到所有参与者返回的事务提交成功的响应之后则完成事务。若协调者在PreCommit阶段**收到了任何一个 NO 或者在一定时间内没有收到所有参与者的响应**，那么就会进行中断请求的发送，参与者收到中断请求后则会**通过上面记录的回滚日志**来进行事务的回滚操作，并向协调者反馈回滚状况，协调者收到参与者返回的消息后，中断事务。

![1732497842539-b83f52c0-c865-44f9-b2f3-534b681bdf7a.jpeg](./img/xOpCaObUO6drnWGP/1732497842539-b83f52c0-c865-44f9-b2f3-534b681bdf7a-982887.jpeg)

3PC流程

这里是3PC在成功的环境下的流程图，你可以看到3PC在很多地方进行了超时中断的处理，比如协调者在指定时间内未收到全部的确认消息则进行事务中断的处理，这样能**减少同步阻塞的时间**。还有需要注意的是，**3PC****在****DoCommit****阶段参与者如未收到协调者发送的提交事务的请求，它会在一定时间内进行事务的提交**。为什么这么做呢？是因为这个时候我们肯定**保证了在第一阶段所有的协调者全部返回了可以执行事务的响应**，这个时候我们有理由**相信其他系统都能进行事务的执行和提交**，所以**不管**协调者有没有发消息给参与者，进入第三阶段参与者都会进行事务的提交操作。

总之，3PC通过一系列的超时机制很好的缓解了阻塞问题，但是最重要的一致性并没有得到根本的解决，比如在DoCommit阶段，当一个参与者收到了请求之后其他参与者和协调者挂了或者出现了网络分区，这个时候收到消息的参与者都会进行事务提交，这就会出现数据不一致性问题。

所以，要解决一致性问题还需要靠Paxos算法 ⭐️ ⭐️ ⭐️ 。

### Paxos算法
Paxos算法是基于**消息传递且具有高度容错特性的一致性算法**，是目前公认的解决分布式一致性问题最有效的算法之一，**其解决的问题就是在分布式系统中如何就某个值（决议）达成一致**。

在Paxos中主要有三个角色，分别为Proposer提案者、Acceptor表决者、Learner学习者。Paxos算法和2PC一样，也有两个阶段，分别为Prepare和accept阶段。

#### prepare 阶段
+ Proposer提案者：负责提出proposal，每个提案者在提出提案时都会首先获取到一个**具有全局唯一性的、递增的提案编号 N**，即在整个集群中是唯一的编号 N，然后将该编号赋予其要提出的提案，在**第一阶段是只将提案编号发送给所有的表决者**。
+ Acceptor表决者：每个表决者在accept某提案后，会将该提案编号 N 记录在本地，这样每个表决者中保存的已经被 accept 的提案中会存在一个**编号最大的提案**，其编号假设为maxN。每个表决者仅会accept编号大于自己本地maxN的提案，在批准提案时表决者会将以前接受过的最大编号的提案作为响应反馈给Proposer。

下面是prepare阶段的流程图，你可以对照着参考一下。

![1732497842641-45deba6c-0279-416f-8b90-d563cfc195db.jpeg](./img/xOpCaObUO6drnWGP/1732497842641-45deba6c-0279-416f-8b90-d563cfc195db-465111.jpeg)

paxos第一阶段

#### accept 阶段
当一个提案被Proposer提出后，如果Proposer收到了超过半数的Acceptor的批准（Proposer本身同意），那么此时Proposer会给所有的Acceptor发送真正的提案（你可以理解为第一阶段为试探），这个时候Proposer就会发送提案的内容和提案编号。

表决者收到提案请求后会再次比较本身已经批准过的最大提案编号和该提案编号，如果该提案编号**大于等于**已经批准过的最大提案编号，那么就accept该提案（此时执行提案内容但不提交），随后将情况返回给Proposer。如果不满足则不回应或者返回 NO 。

![1732497842723-d70660eb-4085-4060-a497-350ec4b0d9bd.jpeg](./img/xOpCaObUO6drnWGP/1732497842723-d70660eb-4085-4060-a497-350ec4b0d9bd-514001.jpeg)

paxos第二阶段1

当Proposer收到超过半数的accept，那么它这个时候会向所有的acceptor发送提案的提交请求。需要注意的是，因为上述仅仅是超过半数的acceptor批准执行了该提案内容，其他没有批准的并没有执行该提案内容，所以这个时候需要**向未批准的****acceptor****发送提案内容和提案编号并让它无条件执行和提交**，而对于前面已经批准过该提案的acceptor来说**仅仅需要发送该提案的编号**，让acceptor执行提交就行了。

![1732497842816-6b761118-4902-4536-a2f2-8d32b7de51c3.jpeg](./img/xOpCaObUO6drnWGP/1732497842816-6b761118-4902-4536-a2f2-8d32b7de51c3-474693.jpeg)

paxos第二阶段2

而如果Proposer如果没有收到超过半数的accept那么它将会将**递增**该Proposal的编号，然后**重新进入****Prepare****阶段**。

对于Learner来说如何去学习Acceptor批准的提案内容，这有很多方式，读者可以自己去了解一下，这里不做过多解释。

#### paxos 算法的死循环问题
其实就有点类似于两个人吵架，小明说我是对的，小红说我才是对的，两个人据理力争的谁也不让谁 🤬🤬。

比如说，此时提案者 P1 提出一个方案 M1，完成了Prepare阶段的工作，这个时候acceptor则批准了 M1，但是此时提案者 P2 同时也提出了一个方案 M2，它也完成了Prepare阶段的工作。然后 P1 的方案已经不能在第二阶段被批准了（因为acceptor已经批准了比 M1 更大的 M2），所以 P1 自增方案变为 M3 重新进入Prepare阶段，然后acceptor，又批准了新的 M3 方案，它又不能批准 M2 了，这个时候 M2 又自增进入Prepare阶段。。。

就这样无休无止的永远提案下去，这就是paxos算法的死循环问题。

![1732497842929-84f0d8d9-1b4e-4adc-846b-8897334e1a2f.jpeg](./img/xOpCaObUO6drnWGP/1732497842929-84f0d8d9-1b4e-4adc-846b-8897334e1a2f-783428.jpeg)

那么如何解决呢？很简单，人多了容易吵架，我现在**就允许一个能提案**就行了。

## 引出 ZAB
### Zookeeper 架构
作为一个优秀高效且可靠的分布式协调框架，ZooKeeper在解决分布式数据一致性问题时并没有直接使用Paxos，而是专门定制了一致性协议叫做ZAB(ZooKeeper Atomic Broadcast)原子广播协议，该协议能够很好地支持**崩溃恢复**。

![1732497843054-6d007a56-99f3-4ea4-8aea-de86b35b6cf9.png](./img/xOpCaObUO6drnWGP/1732497843054-6d007a56-99f3-4ea4-8aea-de86b35b6cf9-894712.png)

Zookeeper架构

### ZAB 中的三个角色
和介绍Paxos一样，在介绍ZAB协议之前，我们首先来了解一下在ZAB中三个主要的角色，Leader 领导者、Follower跟随者、Observer观察者。

+ Leader：集群中**唯一的写请求处理者**，能够发起投票（投票也是为了进行写请求）。
+ Follower：能够接收客户端的请求，如果是读请求则可以自己处理，**如果是写请求则要转发给****Leader**。在选举过程中会参与投票，**有选举权和被选举权**。
+ Observer：就是没有选举权和被选举权的Follower。

在ZAB协议中对zkServer(即上面我们说的三个角色的总称) 还有两种模式的定义，分别是**消息广播**和**崩溃恢复**。

### 消息广播模式
说白了就是ZAB协议是如何处理写请求的，上面我们不是说只有Leader能处理写请求嘛？那么我们的Follower和Observer是不是也需要**同步更新数据**呢？总不能数据只在Leader中更新了，其他角色都没有得到更新吧？

不就是**在整个集群中保持数据的一致性**嘛？如果是你，你会怎么做呢？

废话，第一步肯定需要Leader将写请求**广播**出去呀，让Leader问问Followers是否同意更新，如果超过半数以上的同意那么就进行Follower和Observer的更新（和Paxos一样）。当然这么说有点虚，画张图理解一下。

![1732497843160-df982e0d-ebb2-4f22-bb51-4070577168f9.jpeg](./img/xOpCaObUO6drnWGP/1732497843160-df982e0d-ebb2-4f22-bb51-4070577168f9-830593.jpeg)

消息广播

嗯。。。看起来很简单，貌似懂了 🤥🤥🤥。这两个Queue哪冒出来的？答案是**ZAB****需要让****Follower****和****Observer****保证顺序性**。何为顺序性，比如我现在有一个写请求 A，此时Leader将请求 A 广播出去，因为只需要半数同意就行，所以可能这个时候有一个FollowerF1 因为网络原因没有收到，而Leader又广播了一个请求 B，因为网络原因，F1 竟然先收到了请求 B 然后才收到了请求 A，这个时候请求处理的顺序不同就会导致数据的不同，从而**产生数据不一致问题**。

所以在Leader这端，它为每个其他的zkServer准备了一个**队列**，采用先进先出的方式发送消息。由于协议是**通过****TCP**来进行网络通信的，保证了消息的发送顺序性，接受顺序性也得到了保证。

除此之外，在ZAB中还定义了一个**全局单调递增的事务 ID****ZXID**，它是一个 64 位 long 型，其中高 32 位表示epoch年代，低 32 位表示事务 id。epoch是会根据Leader的变化而变化的，当一个Leader挂了，新的Leader上位的时候，年代（epoch）就变了。而低 32 位可以简单理解为递增的事务 id。

定义这个的原因也是为了顺序性，每个proposal在Leader中生成后需要**通过其****ZXID****来进行排序**，才能得到处理。

### 崩溃恢复模式
说到崩溃恢复我们首先要提到ZAB中的Leader选举算法，当系统出现崩溃影响最大应该是Leader的崩溃，因为我们只有一个Leader，所以当Leader出现问题的时候我们势必需要重新选举Leader。

Leader选举可以分为两个不同的阶段，第一个是我们提到的Leader宕机需要重新选举，第二则是当Zookeeper启动时需要进行系统的Leader初始化选举。下面我先来介绍一下ZAB是如何进行初始化选举的。

假设我们集群中有 3 台机器，那也就意味着我们需要两台以上同意（超过半数）。比如这个时候我们启动了server1，它会首先**投票给自己**，投票内容为服务器的myid和ZXID，因为初始化所以ZXID都为 0，此时server1发出的投票为 (1,0)。但此时server1的投票仅为 1，所以不能作为Leader，此时还在选举阶段所以整个集群处于**Looking****状态**。

接着server2启动了，它首先也会将投票选给自己(2,0)，并将投票信息广播出去（server1也会，只是它那时没有其他的服务器了），server1在收到server2的投票信息后会将投票信息与自己的作比较。**首先它会比较******ZXID**，**ZXID**大的优先为**Leader**，如果相同则比较**myid**，**myid**大的优先作为**Leader****。所以此时server1发现server2更适合做Leader，它就会将自己的投票信息更改为(2,0)然后再广播出去，之后server2收到之后发现和自己的一样无需做更改，并且自己的**投票已经超过半数**，则**确定****server2****为****Leader**，server1也会将自己服务器设置为Following变为Follower。整个服务器就从Looking变为了正常状态。

当server3启动发现集群没有处于Looking状态时，它会直接以Follower的身份加入集群。

还是前面三个server的例子，如果在整个集群运行的过程中server2挂了，那么整个集群会如何重新选举Leader呢？其实和初始化选举差不多。

首先毫无疑问的是剩下的两个Follower会将自己的状态**从****Following****变为****Looking****状态**，然后每个server会向初始化投票一样首先给自己投票（这不过这里的zxid可能不是 0 了，这里为了方便随便取个数字）。

假设server1给自己投票为(1,99)，然后广播给其他server，server3首先也会给自己投票(3,95)，然后也广播给其他server。server1和server3此时会收到彼此的投票信息，和一开始选举一样，他们也会比较自己的投票和收到的投票（zxid大的优先，如果相同那么就myid大的优先）。这个时候server1收到了server3的投票发现没自己的合适故不变，server3收到server1的投票结果后发现比自己的合适于是更改投票为(1,99)然后广播出去，最后server1收到了发现自己的投票已经超过半数就把自己设为Leader，server3也随之变为Follower。

请注意ZooKeeper为什么要设置奇数个结点？比如这里我们是三个，挂了一个我们还能正常工作，挂了两个我们就不能正常工作了（已经没有超过半数的节点数了，所以无法进行投票等操作了）。而假设我们现在有四个，挂了一个也能工作，**但是挂了两个也不能正常工作了**，这是和三个一样的，而三个比四个还少一个，带来的效益是一样的，所以Zookeeper推荐奇数个server。

那么说完了ZAB中的Leader选举方式之后我们再来了解一下**崩溃恢复**是什么玩意？

其实主要就是**当集群中有机器挂了，我们整个集群如何保证数据一致性？**

如果只是Follower挂了，而且挂的没超过半数的时候，因为我们一开始讲了在Leader中会维护队列，所以不用担心后面的数据没接收到导致数据不一致性。

如果Leader挂了那就麻烦了，我们肯定需要先暂停服务变为Looking状态然后进行Leader的重新选举（上面我讲过了），但这个就要分为两种情况了，分别是**确保已经被 Leader 提交的提案最终能够被所有的 Follower 提交**和**跳过那些已经被丢弃的提案**。

确保已经被 Leader 提交的提案最终能够被所有的 Follower 提交是什么意思呢？

假设Leader (server2)发送commit请求（忘了请看上面的消息广播模式），他发送给了server3，然后要发给server1的时候突然挂了。这个时候重新选举的时候我们如果把server1作为Leader的话，那么肯定会产生数据不一致性，因为server3肯定会提交刚刚server2发送的commit请求的提案，而server1根本没收到所以会丢弃。

![1732497843252-4de976d4-065d-4fc9-8f6c-70bb3075950a.jpeg](./img/xOpCaObUO6drnWGP/1732497843252-4de976d4-065d-4fc9-8f6c-70bb3075950a-444231.jpeg)

崩溃恢复

那怎么解决呢？

聪明的同学肯定会质疑，**这个时候****server1****已经不可能成为****Leader****了，因为****server1****和****server3****进行投票选举的时候会比较******ZXID**，而此时**server3**的**ZXID**肯定比**server1**的大了**。(不理解可以看前面的选举算法)

那么跳过那些已经被丢弃的提案又是什么意思呢？

假设Leader (server2)此时同意了提案 N1，自身提交了这个事务并且要发送给所有Follower要commit的请求，却在这个时候挂了，此时肯定要重新进行Leader的选举，比如说此时选server1为Leader（这无所谓）。但是过了一会，这个**挂掉的****Leader****又重新恢复了**，此时它肯定会作为Follower的身份进入集群中，需要注意的是刚刚server2已经同意提交了提案 N1，但其他server并没有收到它的commit信息，所以其他server不可能再提交这个提案 N1 了，这样就会出现数据不一致性问题了，所以**该提案 N1 最终需要被抛弃掉**。

![1732497843343-97c8973e-5010-4750-92e5-881e8320e504.jpeg](./img/xOpCaObUO6drnWGP/1732497843343-97c8973e-5010-4750-92e5-881e8320e504-795106.jpeg)

崩溃恢复

## Zookeeper 的几个理论知识
了解了ZAB协议还不够，它仅仅是Zookeeper内部实现的一种方式，而我们如何通过Zookeeper去做一些典型的应用场景呢？比如说集群管理，分布式锁，Master选举等等。

这就涉及到如何使用Zookeeper了，但在使用之前我们还需要掌握几个概念。比如Zookeeper的**数据模型**、**会话机制**、**ACL**、**Watcher 机制**等等。

### 数据模型
zookeeper数据存储结构与标准的Unix文件系统非常相似，都是在根节点下挂很多子节点(树型)。但是zookeeper中没有文件系统中目录与文件的概念，而是**使用了****znode****作为数据节点**。znode是zookeeper中的最小数据单元，每个znode上都可以保存数据，同时还可以挂载子节点，形成一个树形化命名空间。

![1732497843426-5f003d7e-9ead-49ee-87d1-9d78646f490a.jpeg](./img/xOpCaObUO6drnWGP/1732497843426-5f003d7e-9ead-49ee-87d1-9d78646f490a-442635.jpeg)

zk数据模型

每个znode都有自己所属的**节点类型**和**节点状态**。

其中节点类型可以分为**持久节点**、**持久顺序节点**、**临时节点**和**临时顺序节点**。

+ 持久节点：一旦创建就一直存在，直到将其删除。
+ 持久顺序节点：一个父节点可以为其子节点**维护一个创建的先后顺序**，这个顺序体现在**节点名称**上，是节点名称后自动添加一个由 10 位数字组成的数字串，从 0 开始计数。
+ 临时节点：临时节点的生命周期是与**客户端会话**绑定的，**会话消失则节点消失**。临时节点**只能做叶子节点**，不能创建子节点。
+ 临时顺序节点：父节点可以创建一个维持了顺序的临时节点(和前面的持久顺序性节点一样)。

节点状态中包含了很多节点的属性比如czxid、mzxid等等，在zookeeper中是使用Stat这个类来维护的。下面我列举一些属性解释。

+ czxid：Created ZXID，该数据节点被**创建**时的事务 ID。
+ mzxid：Modified ZXID，节点**最后一次被更新时**的事务 ID。
+ ctime：Created Time，该节点被创建的时间。
+ mtime：Modified Time，该节点最后一次被修改的时间。
+ version：节点的版本号。
+ cversion：**子节点**的版本号。
+ aversion：节点的ACL版本号。
+ ephemeralOwner：创建该节点的会话的sessionID，如果该节点为持久节点，该值为 0。
+ dataLength：节点数据内容的长度。
+ numChildre：该节点的子节点个数，如果为临时节点为 0。
+ pzxid：该节点子节点列表最后一次被修改时的事务 ID，注意是子节点的**列表**，不是内容。

### 会话
我想这个对于后端开发的朋友肯定不陌生，不就是session吗？只不过zk客户端和服务端是通过**TCP****长连接**维持的会话机制，其实对于会话来说你可以理解为**保持连接状态**。

在zookeeper中，会话还有对应的事件，比如CONNECTION_LOSS 连接丢失事件、SESSION_MOVED 会话转移事件、SESSION_EXPIRED 会话超时失效事件。

### ACL
ACL为Access Control Lists，它是一种权限控制。在zookeeper中定义了 5 种权限，它们分别为：

+ CREATE：创建子节点的权限。
+ READ：获取节点数据和子节点列表的权限。
+ WRITE：更新节点数据的权限。
+ DELETE：删除子节点的权限。
+ ADMIN：设置节点 ACL 的权限。

### Watcher 机制
Watcher为事件监听器，是zk非常重要的一个特性，很多功能都依赖于它，它有点类似于订阅的方式，即客户端向服务端**注册**指定的watcher，当服务端符合了watcher的某些事件或要求则会**向客户端发送事件通知**，客户端收到通知后找到自己定义的Watcher然后**执行相应的回调方法**。

![1732497843506-d0beab50-2459-409b-a5d2-8a2eaf7b6d3b.jpeg](./img/xOpCaObUO6drnWGP/1732497843506-d0beab50-2459-409b-a5d2-8a2eaf7b6d3b-717024.jpeg)

watcher机制

## Zookeeper 的几个典型应用场景
前面说了这么多的理论知识，你可能听得一头雾水，这些玩意有啥用？能干啥事？别急，听我慢慢道来。

![1732497843695-cd008060-cc61-4ca9-bfc9-e89287123ff1.jpeg](./img/xOpCaObUO6drnWGP/1732497843695-cd008060-cc61-4ca9-bfc9-e89287123ff1-353171.jpeg)

### 选主
还记得上面我们的所说的临时节点吗？因为Zookeeper的强一致性，能够很好地在保证**在高并发的情况下保证节点创建的全局唯一性**(即无法重复创建同样的节点)。

利用这个特性，我们可以**让多个客户端创建一个指定的节点**，创建成功的就是master。

但是，如果这个master挂了怎么办？？？

你想想为什么我们要创建临时节点？还记得临时节点的生命周期吗？master挂了是不是代表会话断了？会话断了是不是意味着这个节点没了？还记得watcher吗？我们是不是可以**让其他不是****master****的节点监听节点的状态**，比如说我们监听这个临时节点的父节点，如果子节点个数变了就代表master挂了，这个时候我们**触发回调函数进行重新选举**，或者我们直接监听节点的状态，我们可以通过节点是否已经失去连接来判断master是否挂了等等。

![1732497843820-9d9852c5-480a-441a-86eb-7976eb34b094.jpeg](./img/xOpCaObUO6drnWGP/1732497843820-9d9852c5-480a-441a-86eb-7976eb34b094-887299.jpeg)

选主

总的来说，我们可以完全**利用 临时节点、节点状态 和****watcher****来实现选主的功能**，临时节点主要用来选举，节点状态和watcher可以用来判断master的活性和进行重新选举。

### 分布式锁
分布式锁的实现方式有很多种，比如Redis、数据库、zookeeper等。个人认为zookeeper在实现分布式锁这方面是非常非常简单的。

上面我们已经提到过了**zk 在高并发的情况下保证节点创建的全局唯一性**，这玩意一看就知道能干啥了。实现互斥锁呗，又因为能在分布式的情况下，所以能实现分布式锁呗。

如何实现呢？这玩意其实跟选主基本一样，我们也可以利用临时节点的创建来实现。

首先肯定是如何获取锁，因为创建节点的唯一性，我们可以让多个客户端同时创建一个临时节点，**创建成功的就说明获取到了锁**。然后没有获取到锁的客户端也像上面选主的非主节点创建一个watcher进行节点状态的监听，如果这个互斥锁被释放了（可能获取锁的客户端宕机了，或者那个客户端主动释放了锁）可以调用回调函数重新获得锁。

zk中不需要向redis那样考虑锁得不到释放的问题了，因为当客户端挂了，节点也挂了，锁也释放了。是不是很简单？

那能不能使用zookeeper同时实现**共享锁和独占锁**呢？答案是可以的，不过稍微有点复杂而已。

还记得**有序的节点**吗？

这个时候我规定所有创建节点必须有序，当你是读请求（要获取共享锁）的话，如果**没有比自己更小的节点，或比自己小的节点都是读请求**，则可以获取到读锁，然后就可以开始读了。**若比自己小的节点中有写请求**，则当前客户端无法获取到读锁，只能等待前面的写请求完成。

如果你是写请求（获取独占锁），若**没有比自己更小的节点**，则表示当前客户端可以直接获取到写锁，对数据进行修改。若发现**有比自己更小的节点，无论是读操作还是写操作，当前客户端都无法获取到写锁**，等待所有前面的操作完成。

这就很好地同时实现了共享锁和独占锁，当然还有优化的地方，比如当一个锁得到释放它会通知所有等待的客户端从而造成**羊群效应**。此时你可以通过让等待的节点只监听他们前面的节点。

具体怎么做呢？其实也很简单，你可以让**读请求监听比自己小的最后一个写请求节点，写请求只监听比自己小的最后一个节点**，感兴趣的小伙伴可以自己去研究一下。

### 命名服务
如何给一个对象设置 ID，大家可能都会想到UUID，但是UUID最大的问题就在于它太长了。。。(太长不一定是好事，嘿嘿嘿)。那么在条件允许的情况下，我们能不能使用zookeeper来实现呢？

我们之前提到过zookeeper是通过**树形结构**来存储数据节点的，那也就是说，对于每个节点的**全路径**，它必定是唯一的，我们可以使用节点的全路径作为命名方式了。而且更重要的是，路径是我们可以自己定义的，这对于我们对有些有语意的对象的 ID 设置可以更加便于理解。

### 集群管理和注册中心
看到这里是不是觉得zookeeper实在是太强大了，它怎么能这么能干！

别急，它能干的事情还很多呢。可能我们会有这样的需求，我们需要了解整个集群中有多少机器在工作，我们想对集群中的每台机器的运行时状态进行数据采集，对集群中机器进行上下线操作等等。

而zookeeper天然支持的watcher和 临时节点能很好的实现这些需求。我们可以为每条机器创建临时节点，并监控其父节点，如果子节点列表有变动（我们可能创建删除了临时节点），那么我们可以使用在其父节点绑定的watcher进行状态监控和回调。

![1732497843912-51f55b8a-37dc-4d7d-a1c7-08587571e717.jpeg](./img/xOpCaObUO6drnWGP/1732497843912-51f55b8a-37dc-4d7d-a1c7-08587571e717-166069.jpeg)

集群管理

至于注册中心也很简单，我们同样也是让**服务提供者**在zookeeper中创建一个临时节点并且将自己的ip、port、调用方式写入节点，当**服务消费者**需要进行调用的时候会**通过注册中心找到相应的服务的地址列表(IP 端口什么的)**，并缓存到本地(方便以后调用)，当消费者调用服务时，不会再去请求注册中心，而是直接通过负载均衡算法从地址列表中取一个服务提供者的服务器调用服务。

当服务提供者的某台服务器宕机或下线时，相应的地址会从服务提供者地址列表中移除。同时，注册中心会将新的服务地址列表发送给服务消费者的机器并缓存在消费者本机（当然你可以让消费者进行节点监听，我记得Eureka会先试错，然后再更新）。

![1732497844006-102aab76-21a4-470d-b511-0ea1cf3e799c.jpeg](./img/xOpCaObUO6drnWGP/1732497844006-102aab76-21a4-470d-b511-0ea1cf3e799c-771988.jpeg)

注册中心

## 总结
看到这里的同学实在是太有耐心了 👍👍👍 不知道大家是否还记得我讲了什么 😒。

![1732497844096-f2890c0c-2098-4a20-81db-eb58caba0783.jpeg](./img/xOpCaObUO6drnWGP/1732497844096-f2890c0c-2098-4a20-81db-eb58caba0783-755763.jpeg)

这篇文章中我带大家入门了zookeeper这个强大的分布式协调框架。现在我们来简单梳理一下整篇文章的内容。

+ 分布式与集群的区别
+ 2PC、3PC以及paxos算法这些一致性框架的原理和实现。
+ zookeeper专门的一致性算法ZAB原子广播协议的内容（Leader选举、崩溃恢复、消息广播）。
+ zookeeper中的一些基本概念，比如ACL，数据节点，会话，watcher机制等等。
+ zookeeper的典型应用场景，比如选主，注册中心等等。如果忘了可以回去看看再次理解一下，如果有疑问和建议欢迎提出 🤝🤝🤝。



> 更新: 2024-01-03 20:53:20  
原文: [https://www.yuque.com/vip6688/neho4x/pxw8ta3zsqu666om](https://www.yuque.com/vip6688/neho4x/pxw8ta3zsqu666om)
>



> 更新: 2024-11-25 09:24:04  
> 原文: <https://www.yuque.com/neumx/laxg2e/78aa81cffbd8f303ad08a9c71ab1cbe5>