# 场景题

1.  场景题:有A和B两个系统，A通过RPC接口调用B，有一个逻辑需要保证AB系统状态一致，A里有一个方法，加了transactional注解，该方法逻辑是先通过rpc 调用B系统，B系统更新状态为生效中，根据B系统返回的结果更新自己本地的数据库为生效中，你觉得会出现什么问题？

<details class="lake-collapse"><summary id="u552e1c24"></summary><h3 id="d3a783b9"><span class="ne-text">场景题 1</span></h3><p id="uf32a93f0" class="ne-p"><strong><span class="ne-text">问题描述</span></strong><span class="ne-text">：A系统通过RPC调用B系统，A中方法加了</span><code class="ne-code"><span class="ne-text">@Transactional</span></code><span class="ne-text">注解，调用逻辑是：</span></p><ol class="ne-ol"><li id="ubbc02b9f" data-lake-index-type="0"><span class="ne-text">A调用B更新B状态为“生效中”。</span></li><li id="uc995abbc" data-lake-index-type="0"><span class="ne-text">根据B返回的结果更新A自己的数据库状态为“生效中”。 </span><strong><span class="ne-text">需要保证AB状态一致</span></strong><span class="ne-text">。</span></li></ol><p id="u7332922a" class="ne-p"><strong><span class="ne-text">潜在问题</span></strong><span class="ne-text">：</span></p><ol class="ne-ol"><li id="u2366a2f6" data-lake-index-type="0"><strong><span class="ne-text">分布式事务问题</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ud3024f48" data-lake-index-type="0"><code class="ne-code"><span class="ne-text">@Transactional</span></code><span class="ne-text">只能保证A系统内的本地事务一致性，无法跨越RPC调用边界管理B系统的事务。B的状态更新成功后，A的事务如果回滚，B系统的状态不会随之回滚，导致AB状态不一致。</span></li><li id="ue001c94e" data-lake-index-type="0"><span class="ne-text">例如，A调用B成功后，A系统在更新本地数据库状态时失败（如网络异常或数据约束问题），此时B的状态已经生效中，但A的状态未更新。</span></li></ul></ul><ol start="2" class="ne-ol"><li id="u19edde07" data-lake-index-type="0"><strong><span class="ne-text">网络和服务不可用问题</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u847496b2" data-lake-index-type="0"><span class="ne-text">如果A系统调用B系统时网络出现超时或调用失败，但B系统的状态实际已更新成功，而A系统因为未收到正确的返回值，可能不会更新其状态，从而再次导致状态不一致。</span></li></ul></ul><ol start="3" class="ne-ol"><li id="uefd4e9f6" data-lake-index-type="0"><strong><span class="ne-text">幂等性问题</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="uffb5a1c5" data-lake-index-type="0"><span class="ne-text">如果A系统因网络中断未接收到B的返回值，可能会重试调用B系统，导致B的状态多次更新，虽然最终状态可能一致，但中间的重复更新会带来额外的复杂性。</span></li></ul></ul><p id="u9f79d628" class="ne-p"><strong><span class="ne-text">解决方案</span></strong><span class="ne-text">：</span></p><ul class="ne-ul"><li id="u70c23bc5" data-lake-index-type="0"><strong><span class="ne-text">分布式事务解决方案</span></strong><span class="ne-text">：</span></li></ul><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u4f1e9236" data-lake-index-type="0"><strong><span class="ne-text">TCC（Try-Confirm-Cancel）</span></strong><span class="ne-text">：</span></li></ol></ol><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u32c771d6" data-lake-index-type="0"><span class="ne-text">A调用B时，分两个阶段：</span></li></ul></ul></ul><ol class="ne-list-wrap"><ol class="ne-list-wrap"><ol class="ne-list-wrap"><ol ne-level="3" class="ne-ol"><li id="ufca285ee" data-lake-index-type="0"><span class="ne-text">Try阶段：在A和B系统中都预留资源，标记状态为“待生效”。</span></li><li id="u67e38db3" data-lake-index-type="0"><span class="ne-text">Confirm阶段：确保Try阶段成功后，再正式提交事务，更新状态为“生效中”。</span></li><li id="u79a8e58e" data-lake-index-type="0"><span class="ne-text">Cancel阶段：Try阶段失败时，回滚所有的预留资源。</span></li></ol></ol></ol></ol><ol class="ne-list-wrap"><ol ne-level="1" class="ne-ol"><li id="u84e995bd" data-lake-index-type="0"><strong><span class="ne-text">消息队列（异步最终一致性）</span></strong><span class="ne-text">：</span></li></ol></ol><ul class="ne-list-wrap"><ul class="ne-list-wrap"><ul ne-level="2" class="ne-ul"><li id="u4099e24f" data-lake-index-type="0"><span class="ne-text">使用消息队列（如Kafka、RocketMQ）记录A系统的状态更新任务，确保A在本地事务提交成功后，发布消息给B系统，B根据消息更新自身状态。</span></li></ul></ul></ul><ul class="ne-ul"><li id="ub85ad4f6" data-lake-index-type="0"><strong><span class="ne-text">幂等性设计</span></strong><span class="ne-text">：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ua8d8ab57" data-lake-index-type="0"><span class="ne-text">确保B系统的接口是幂等的，即同样的请求多次调用不会对B的最终状态产生额外影响。</span></li></ul></ul><ul class="ne-ul"><li id="ufe581c0b" data-lake-index-type="0"><strong><span class="ne-text">接口设计</span></strong><span class="ne-text">：</span></li></ul><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="u7dee8b0f" data-lake-index-type="0"><span class="ne-text">A调用B接口时，返回值需要明确成功或失败，且需要记录每次操作的唯一标识（如事务ID），用于排查异常。</span></li></ul></ul></details>
2. 场景题:两个类A和B，A通过Autowired引用了B，B也以同样的方法引用了A，这时候服务可以正常启动吗，为什么？

<details class="lake-collapse"><summary id="u2a956fe2"></summary><h3 id="KLueh"><span class="ne-text">场景题 2</span></h3><p id="u1ba3c1a1" class="ne-p"><strong><span class="ne-text">问题描述</span></strong><span class="ne-text">：两个类A和B，A通过</span><code class="ne-code"><span class="ne-text">@Autowired</span></code><span class="ne-text">注入了B，B通过</span><code class="ne-code"><span class="ne-text">@Autowired</span></code><span class="ne-text">注入了A，问服务是否可以正常启动。</span></p><p id="u1728462c" class="ne-p"><strong><span class="ne-text">答案</span></strong><span class="ne-text">：</span></p><ul class="ne-ul"><li id="u1081f54e" data-lake-index-type="0"><strong><span class="ne-text">启动会失败</span></strong><span class="ne-text">。</span></li><li id="u1ef45649" data-lake-index-type="0"><span class="ne-text">原因是 </span><strong><span class="ne-text">循环依赖</span></strong><span class="ne-text"> 问题。</span></li></ul><p id="u60e03ad3" class="ne-p"><strong><span class="ne-text">详细原因</span></strong><span class="ne-text">：</span></p><ol class="ne-ol"><li id="u4c42f34e" data-lake-index-type="0"><span class="ne-text">Spring的</span><code class="ne-code"><span class="ne-text">@Autowired</span></code><span class="ne-text">默认采用的是</span><strong><span class="ne-text">构造器注入</span></strong><span class="ne-text">（如果没有显式配置其他注入方式）。</span></li><li id="u637f88d5" data-lake-index-type="0"><span class="ne-text">在构造器注入的情况下，A需要B的实例，而B也需要A的实例，形成了循环依赖，Spring容器在创建A和B的过程中会进入死循环，最终导致启动失败。</span></li></ol><p id="uadfab6e2" class="ne-p"><strong><span class="ne-text">如何解决循环依赖</span></strong><span class="ne-text">：</span></p><ol class="ne-ol"><li id="u0d1c1710" data-lake-index-type="0"><strong><span class="ne-text">使用</span></strong><code class="ne-code"><span class="ne-text">@Lazy</span></code><strong><span class="ne-text">注解</span></strong><span class="ne-text">：</span></li></ol><pre data-language="java" id="TAotv" class="ne-codeblock language-java"><code>@Component
public class A {
    @Autowired
    @Lazy
    private B b;
}</code></pre><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ud8513898" data-lake-index-type="0"><span class="ne-text">在其中一个类的注入中加上</span><code class="ne-code"><span class="ne-text">@Lazy</span></code><span class="ne-text">，延迟注入对象的加载。</span></li><li id="u9dd4f9f0" data-lake-index-type="0"><span class="ne-text">这样，Spring容器会先创建A实例，然后延迟注入B，避免循环依赖问题。</span></li></ul></ul><ol start="2" class="ne-ol"><li id="u711b67bb" data-lake-index-type="0"><strong><span class="ne-text">使用</span></strong><code class="ne-code"><span class="ne-text">Setter</span></code><strong><span class="ne-text">注入或</span></strong><code class="ne-code"><span class="ne-text">Field</span></code><strong><span class="ne-text">注入</span></strong><span class="ne-text">：</span></li></ol><pre data-language="java" id="yxOVY" class="ne-codeblock language-java"><code>@Component
public class A {
    @Autowired
    private B b;
}

@Component
public class B {
    @Autowired
    private A a;
}</code></pre><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="uc68bc89f" data-lake-index-type="0"><span class="ne-text">Spring的Setter注入或Field注入支持先实例化对象，再完成属性注入，可以避免循环依赖。</span></li></ul></ul><ol start="3" class="ne-ol"><li id="u6039271c" data-lake-index-type="0"><strong><span class="ne-text">重构代码</span></strong><span class="ne-text">：</span></li></ol><ul class="ne-list-wrap"><ul ne-level="1" class="ne-ul"><li id="ud055f987" data-lake-index-type="0"><span class="ne-text">检查设计是否存在问题。通常，循环依赖反映了耦合过高的代码设计。可以通过重构代码，分离A和B的依赖逻辑，减少耦合。</span></li></ul></ul><p id="ua0f99056" class="ne-p"><strong><span class="ne-text">总结</span></strong><span class="ne-text">：</span></p><ul class="ne-ul"><li id="u93c9f904" data-lake-index-type="0"><span class="ne-text">如果不处理，服务无法正常启动。</span></li><li id="u63e0b9ed" data-lake-index-type="0"><span class="ne-text">推荐通过**</span><code class="ne-code"><span class="ne-text">@Lazy</span></code><span class="ne-text">延迟加载</span><strong><span class="ne-text">或</span></strong><span class="ne-text">代码重构**解决循环依赖问题。</span></li></ul></details>


> 更新: 2025-01-13 16:35:50  
> 原文: <https://www.yuque.com/neumx/laxg2e/uxz1z28l2rl2xx5n>